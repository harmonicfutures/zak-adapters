{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\helpers.rs","byte_start":12073,"byte_end":12076,"line_start":391,"line_end":391,"column_start":20,"column_end":23,"is_primary":true,"text":[{"text":"    read_str_bytes(len, dest)","highlight_start":20,"highlight_end":23}],"label":"expected `i64`, found `i32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\helpers.rs","byte_start":12058,"byte_end":12072,"line_start":391,"line_end":391,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    read_str_bytes(len, dest)","highlight_start":5,"highlight_end":19}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\helpers.rs","byte_start":12105,"byte_end":12113,"line_start":394,"line_end":394,"column_start":19,"column_end":27,"is_primary":false,"text":[{"text":"fn read_str_bytes(len: i64, dest: &[u8]) -> Result<&[u8], c_long> {","highlight_start":19,"highlight_end":27}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\helpers.rs","byte_start":12090,"byte_end":12104,"line_start":394,"line_end":394,"column_start":4,"column_end":18,"is_primary":true,"text":[{"text":"fn read_str_bytes(len: i64, dest: &[u8]) -> Result<&[u8], c_long> {","highlight_start":4,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert an `i32` to an `i64`","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\helpers.rs","byte_start":12076,"byte_end":12076,"line_start":391,"line_end":391,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"    read_str_bytes(len, dest)","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\helpers.rs:391:20\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m391\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     read_str_bytes(len, dest)\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m--------------\u001b[0m \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mexpected `i64`, found `i32`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96marguments to this function are incorrect\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\helpers.rs:394:4\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m394\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn read_str_bytes(len: i64, dest: &[u8]) -> Result<&[u8], \u001b[1m\u001b[96m...\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m    \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[96m--------\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert an `i32` to an `i64`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m391\u001b[0m \u001b[1m\u001b[96m| \u001b[0m    read_str_bytes(len\u001b[92m.into()\u001b[0m, dest)\n    \u001b[1m\u001b[96m|\u001b[0m                       \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\helpers.rs","byte_start":17034,"byte_end":17037,"line_start":544,"line_end":544,"column_start":20,"column_end":23,"is_primary":true,"text":[{"text":"    read_str_bytes(len, dest)","highlight_start":20,"highlight_end":23}],"label":"expected `i64`, found `i32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\helpers.rs","byte_start":17019,"byte_end":17033,"line_start":544,"line_end":544,"column_start":5,"column_end":19,"is_primary":false,"text":[{"text":"    read_str_bytes(len, dest)","highlight_start":5,"highlight_end":19}],"label":"arguments to this function are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"function defined here","code":null,"level":"note","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\helpers.rs","byte_start":12105,"byte_end":12113,"line_start":394,"line_end":394,"column_start":19,"column_end":27,"is_primary":false,"text":[{"text":"fn read_str_bytes(len: i64, dest: &[u8]) -> Result<&[u8], c_long> {","highlight_start":19,"highlight_end":27}],"label":"","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\helpers.rs","byte_start":12090,"byte_end":12104,"line_start":394,"line_end":394,"column_start":4,"column_end":18,"is_primary":true,"text":[{"text":"fn read_str_bytes(len: i64, dest: &[u8]) -> Result<&[u8], c_long> {","highlight_start":4,"highlight_end":18}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert an `i32` to an `i64`","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\helpers.rs","byte_start":17037,"byte_end":17037,"line_start":544,"line_end":544,"column_start":23,"column_end":23,"is_primary":true,"text":[{"text":"    read_str_bytes(len, dest)","highlight_start":23,"highlight_end":23}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\helpers.rs:544:20\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m544\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     read_str_bytes(len, dest)\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m--------------\u001b[0m \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mexpected `i64`, found `i32`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m     \u001b[1m\u001b[96marguments to this function are incorrect\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: function defined here\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\helpers.rs:394:4\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m394\u001b[0m \u001b[1m\u001b[96m|\u001b[0m fn read_str_bytes(len: i64, dest: &[u8]) -> Result<&[u8], \u001b[1m\u001b[96m...\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m    \u001b[1m\u001b[92m^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[96m--------\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert an `i32` to an `i64`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m544\u001b[0m \u001b[1m\u001b[96m| \u001b[0m    read_str_bytes(len\u001b[92m.into()\u001b[0m, dest)\n    \u001b[1m\u001b[96m|\u001b[0m                       \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"`match` arms have incompatible types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\helpers.rs","byte_start":25292,"byte_end":25326,"line_start":805,"line_end":805,"column_start":14,"column_end":48,"is_primary":true,"text":[{"text":"        1 => printk(fmt_ptr, fmt_size, args[0]),","highlight_start":14,"highlight_end":48}],"label":"expected `i64`, found `i32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\helpers.rs","byte_start":25245,"byte_end":25277,"line_start":804,"line_end":804,"column_start":14,"column_end":46,"is_primary":false,"text":[{"text":"        0 => printk(fmt_ptr, fmt_size).into(),","highlight_start":14,"highlight_end":46}],"label":"this is found to be of type `i64`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\helpers.rs","byte_start":25215,"byte_end":25682,"line_start":803,"line_end":816,"column_start":5,"column_end":6,"is_primary":false,"text":[{"text":"    match NUM_ARGS {","highlight_start":5,"highlight_end":21},{"text":"        0 => printk(fmt_ptr, fmt_size).into(),","highlight_start":1,"highlight_end":47},{"text":"        1 => printk(fmt_ptr, fmt_size, args[0]),","highlight_start":1,"highlight_end":49},{"text":"        2 => printk(fmt_ptr, fmt_size, args[0], args[1]),","highlight_start":1,"highlight_end":58},{"text":"        3 => printk(fmt_ptr, fmt_size, args[0], args[1], args[2]),","highlight_start":1,"highlight_end":67},{"text":"        _ => unsafe {","highlight_start":1,"highlight_end":22},{"text":"            generated::bpf_trace_vprintk(","highlight_start":1,"highlight_end":42},{"text":"                fmt_ptr,","highlight_start":1,"highlight_end":25},{"text":"                fmt_size,","highlight_start":1,"highlight_end":26},{"text":"                args.as_ptr().cast(),","highlight_start":1,"highlight_end":38},{"text":"                (NUM_ARGS * 8) as u32,","highlight_start":1,"highlight_end":39},{"text":"            ).into()","highlight_start":1,"highlight_end":21},{"text":"        },","highlight_start":1,"highlight_end":11},{"text":"    }","highlight_start":1,"highlight_end":6}],"label":"`match` arms have incompatible types","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can convert an `i32` to an `i64`","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\helpers.rs","byte_start":25326,"byte_end":25326,"line_start":805,"line_end":805,"column_start":48,"column_end":48,"is_primary":true,"text":[{"text":"        1 => printk(fmt_ptr, fmt_size, args[0]),","highlight_start":48,"highlight_end":48}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: `match` arms have incompatible types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\helpers.rs:805:14\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m803\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m/\u001b[0m     match NUM_ARGS {\n\u001b[1m\u001b[96m804\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         0 => printk(fmt_ptr, fmt_size).into(),\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[96m--------------------------------\u001b[0m \u001b[1m\u001b[96mthis is found to be of type `i64`\u001b[0m\n\u001b[1m\u001b[96m805\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         1 => printk(fmt_ptr, fmt_size, args[0]),\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m              \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `i64`, found `i32`\u001b[0m\n\u001b[1m\u001b[96m806\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         2 => printk(fmt_ptr, fmt_size, args[0], args[1]),\n\u001b[1m\u001b[96m...\u001b[0m   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m815\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         },\n\u001b[1m\u001b[96m816\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|\u001b[0m     }\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m|_____-\u001b[0m \u001b[1m\u001b[96m`match` arms have incompatible types\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert an `i32` to an `i64`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m805\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        1 => printk(fmt_ptr, fmt_size, args[0])\u001b[92m.into()\u001b[0m,\n    \u001b[1m\u001b[96m|\u001b[0m                                                \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\bloom_filter.rs","byte_start":1300,"byte_end":1303,"line_start":48,"line_end":48,"column_start":40,"column_end":43,"is_primary":true,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":40,"highlight_end":43}],"label":"expected `i64`, found `i32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\bloom_filter.rs","byte_start":1294,"byte_end":1299,"line_start":48,"line_end":48,"column_start":34,"column_end":39,"is_primary":false,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":34,"highlight_end":39}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the return type of this call is `i32` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\bloom_filter.rs","byte_start":1300,"byte_end":1303,"line_start":48,"line_end":48,"column_start":40,"column_end":43,"is_primary":false,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":40,"highlight_end":43}],"label":"this argument influences the return type of `ok_or`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\bloom_filter.rs","byte_start":1269,"byte_end":1304,"line_start":48,"line_end":48,"column_start":9,"column_end":44,"is_primary":true,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":9,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\option.rs","byte_start":49826,"byte_end":49831,"line_start":1336,"line_end":1336,"column_start":18,"column_end":23,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert an `i32` to an `i64`","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\bloom_filter.rs","byte_start":1303,"byte_end":1303,"line_start":48,"line_end":48,"column_start":43,"column_end":43,"is_primary":true,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":43,"highlight_end":43}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\bloom_filter.rs:48:40\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m48\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         (ret == 0).then_some(()).ok_or(ret)\n   \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[96m-----\u001b[0m \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mexpected `i64`, found `i32`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[96marguments to this method are incorrect\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the return type of this call is `i32` due to the type of the argument passed\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\bloom_filter.rs:48:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m48\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         (ret == 0).then_some(()).ok_or(ret)\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[1m\u001b[96m---\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[96mthis argument influences the return type of `ok_or`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n  \u001b[1m\u001b[96m--> \u001b[0m/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\option.rs:1336:18\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert an `i32` to an `i64`\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m48\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        (ret == 0).then_some(()).ok_or(ret\u001b[92m.into()\u001b[0m)\n   \u001b[1m\u001b[96m|\u001b[0m                                           \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\bloom_filter.rs","byte_start":1670,"byte_end":1673,"line_start":60,"line_end":60,"column_start":40,"column_end":43,"is_primary":true,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":40,"highlight_end":43}],"label":"expected `i64`, found `i32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\bloom_filter.rs","byte_start":1664,"byte_end":1669,"line_start":60,"line_end":60,"column_start":34,"column_end":39,"is_primary":false,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":34,"highlight_end":39}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the return type of this call is `i32` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\bloom_filter.rs","byte_start":1670,"byte_end":1673,"line_start":60,"line_end":60,"column_start":40,"column_end":43,"is_primary":false,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":40,"highlight_end":43}],"label":"this argument influences the return type of `ok_or`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\bloom_filter.rs","byte_start":1639,"byte_end":1674,"line_start":60,"line_end":60,"column_start":9,"column_end":44,"is_primary":true,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":9,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\option.rs","byte_start":49826,"byte_end":49831,"line_start":1336,"line_end":1336,"column_start":18,"column_end":23,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert an `i32` to an `i64`","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\bloom_filter.rs","byte_start":1673,"byte_end":1673,"line_start":60,"line_end":60,"column_start":43,"column_end":43,"is_primary":true,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":43,"highlight_end":43}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\bloom_filter.rs:60:40\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m60\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         (ret == 0).then_some(()).ok_or(ret)\n   \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[96m-----\u001b[0m \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mexpected `i64`, found `i32`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[96marguments to this method are incorrect\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the return type of this call is `i32` due to the type of the argument passed\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\bloom_filter.rs:60:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m60\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         (ret == 0).then_some(()).ok_or(ret)\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[1m\u001b[96m---\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[96mthis argument influences the return type of `ok_or`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n  \u001b[1m\u001b[96m--> \u001b[0m/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\option.rs:1336:18\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert an `i32` to an `i64`\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m60\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        (ret == 0).then_some(()).ok_or(ret\u001b[92m.into()\u001b[0m)\n   \u001b[1m\u001b[96m|\u001b[0m                                           \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\queue.rs","byte_start":1653,"byte_end":1656,"line_start":56,"line_end":56,"column_start":40,"column_end":43,"is_primary":true,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":40,"highlight_end":43}],"label":"expected `i64`, found `i32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\queue.rs","byte_start":1647,"byte_end":1652,"line_start":56,"line_end":56,"column_start":34,"column_end":39,"is_primary":false,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":34,"highlight_end":39}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the return type of this call is `i32` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\queue.rs","byte_start":1653,"byte_end":1656,"line_start":56,"line_end":56,"column_start":40,"column_end":43,"is_primary":false,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":40,"highlight_end":43}],"label":"this argument influences the return type of `ok_or`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\queue.rs","byte_start":1622,"byte_end":1657,"line_start":56,"line_end":56,"column_start":9,"column_end":44,"is_primary":true,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":9,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\option.rs","byte_start":49826,"byte_end":49831,"line_start":1336,"line_end":1336,"column_start":18,"column_end":23,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert an `i32` to an `i64`","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\queue.rs","byte_start":1656,"byte_end":1656,"line_start":56,"line_end":56,"column_start":43,"column_end":43,"is_primary":true,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":43,"highlight_end":43}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\queue.rs:56:40\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m56\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         (ret == 0).then_some(()).ok_or(ret)\n   \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[96m-----\u001b[0m \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mexpected `i64`, found `i32`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[96marguments to this method are incorrect\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the return type of this call is `i32` due to the type of the argument passed\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\queue.rs:56:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m56\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         (ret == 0).then_some(()).ok_or(ret)\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[1m\u001b[96m---\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[96mthis argument influences the return type of `ok_or`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n  \u001b[1m\u001b[96m--> \u001b[0m/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\option.rs:1336:18\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert an `i32` to an `i64`\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m56\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        (ret == 0).then_some(()).ok_or(ret\u001b[92m.into()\u001b[0m)\n   \u001b[1m\u001b[96m|\u001b[0m                                           \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\ring_buf.rs","byte_start":7625,"byte_end":7628,"line_start":220,"line_end":220,"column_start":26,"column_end":29,"is_primary":true,"text":[{"text":"        if ret < 0 { Err(ret) } else { Ok(()) }","highlight_start":26,"highlight_end":29}],"label":"expected `i64`, found `i32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\ring_buf.rs","byte_start":7621,"byte_end":7624,"line_start":220,"line_end":220,"column_start":22,"column_end":25,"is_primary":false,"text":[{"text":"        if ret < 0 { Err(ret) } else { Ok(()) }","highlight_start":22,"highlight_end":25}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the type constructed contains `i32` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\ring_buf.rs","byte_start":7625,"byte_end":7628,"line_start":220,"line_end":220,"column_start":26,"column_end":29,"is_primary":false,"text":[{"text":"        if ret < 0 { Err(ret) } else { Ok(()) }","highlight_start":26,"highlight_end":29}],"label":"this argument influences the type of `Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\ring_buf.rs","byte_start":7621,"byte_end":7629,"line_start":220,"line_end":220,"column_start":22,"column_end":30,"is_primary":true,"text":[{"text":"        if ret < 0 { Err(ret) } else { Ok(()) }","highlight_start":22,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\result.rs","byte_start":21514,"byte_end":21517,"line_start":566,"line_end":566,"column_start":5,"column_end":8,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert an `i32` to an `i64`","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\ring_buf.rs","byte_start":7628,"byte_end":7628,"line_start":220,"line_end":220,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"        if ret < 0 { Err(ret) } else { Ok(()) }","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\ring_buf.rs:220:26\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m220\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if ret < 0 { Err(ret) } else { Ok(()) }\n    \u001b[1m\u001b[96m|\u001b[0m                      \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mexpected `i64`, found `i32`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                      \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                      \u001b[1m\u001b[96marguments to this enum variant are incorrect\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `i32` due to the type of the argument passed\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\ring_buf.rs:220:22\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m220\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if ret < 0 { Err(ret) } else { Ok(()) }\n    \u001b[1m\u001b[96m|\u001b[0m                      \u001b[1m\u001b[96m^^^^\u001b[0m\u001b[1m\u001b[96m---\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                          \u001b[1m\u001b[96m|\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m                          \u001b[1m\u001b[96mthis argument influences the type of `Err`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n   \u001b[1m\u001b[96m--> \u001b[0m/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\result.rs:566:5\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert an `i32` to an `i64`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m220\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        if ret < 0 { Err(ret\u001b[92m.into()\u001b[0m) } else { Ok(()) }\n    \u001b[1m\u001b[96m|\u001b[0m                             \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_hash.rs","byte_start":2077,"byte_end":2080,"line_start":73,"line_end":73,"column_start":40,"column_end":43,"is_primary":true,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":40,"highlight_end":43}],"label":"expected `i64`, found `i32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_hash.rs","byte_start":2071,"byte_end":2076,"line_start":73,"line_end":73,"column_start":34,"column_end":39,"is_primary":false,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":34,"highlight_end":39}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the return type of this call is `i32` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_hash.rs","byte_start":2077,"byte_end":2080,"line_start":73,"line_end":73,"column_start":40,"column_end":43,"is_primary":false,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":40,"highlight_end":43}],"label":"this argument influences the return type of `ok_or`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_hash.rs","byte_start":2046,"byte_end":2081,"line_start":73,"line_end":73,"column_start":9,"column_end":44,"is_primary":true,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":9,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\option.rs","byte_start":49826,"byte_end":49831,"line_start":1336,"line_end":1336,"column_start":18,"column_end":23,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert an `i32` to an `i64`","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_hash.rs","byte_start":2080,"byte_end":2080,"line_start":73,"line_end":73,"column_start":43,"column_end":43,"is_primary":true,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":43,"highlight_end":43}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_hash.rs:73:40\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m73\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         (ret == 0).then_some(()).ok_or(ret)\n   \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[96m-----\u001b[0m \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mexpected `i64`, found `i32`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[96marguments to this method are incorrect\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the return type of this call is `i32` due to the type of the argument passed\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_hash.rs:73:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m73\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         (ret == 0).then_some(()).ok_or(ret)\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[1m\u001b[96m---\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[96mthis argument influences the return type of `ok_or`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n  \u001b[1m\u001b[96m--> \u001b[0m/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\option.rs:1336:18\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert an `i32` to an `i64`\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m73\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        (ret == 0).then_some(()).ok_or(ret\u001b[92m.into()\u001b[0m)\n   \u001b[1m\u001b[96m|\u001b[0m                                           \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_hash.rs","byte_start":2269,"byte_end":2457,"line_start":83,"line_end":88,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            bpf_msg_redirect_hash(","highlight_start":13,"highlight_end":35},{"text":"                ctx.borrow().msg,","highlight_start":1,"highlight_end":34},{"text":"                self.def.get().cast(),","highlight_start":1,"highlight_end":39},{"text":"                ptr::from_mut(key.borrow_mut()).cast(),","highlight_start":1,"highlight_end":56},{"text":"                flags,","highlight_start":1,"highlight_end":23},{"text":"            )","highlight_start":1,"highlight_end":14}],"label":"expected `i64`, found `i32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_hash.rs","byte_start":2234,"byte_end":2237,"line_start":81,"line_end":81,"column_start":10,"column_end":13,"is_primary":false,"text":[{"text":"    ) -> i64 {","highlight_start":10,"highlight_end":13}],"label":"expected `i64` because of return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can convert an `i32` to an `i64`","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_hash.rs","byte_start":2457,"byte_end":2457,"line_start":88,"line_end":88,"column_start":14,"column_end":14,"is_primary":true,"text":[{"text":"            )","highlight_start":14,"highlight_end":14}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_hash.rs:83:13\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m81\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       ) -> i64 {\n   \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[96mexpected `i64` because of return type\u001b[0m\n\u001b[1m\u001b[96m82\u001b[0m \u001b[1m\u001b[96m|\u001b[0m           unsafe {\n\u001b[1m\u001b[96m83\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m             bpf_msg_redirect_hash(\n\u001b[1m\u001b[96m84\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 ctx.borrow().msg,\n\u001b[1m\u001b[96m85\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 self.def.get().cast(),\n\u001b[1m\u001b[96m86\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 ptr::from_mut(key.borrow_mut()).cast(),\n\u001b[1m\u001b[96m87\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 flags,\n\u001b[1m\u001b[96m88\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             )\n   \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____________^\u001b[0m \u001b[1m\u001b[91mexpected `i64`, found `i32`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert an `i32` to an `i64`\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m88\u001b[0m \u001b[1m\u001b[96m| \u001b[0m            )\u001b[92m.into()\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m              \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_hash.rs","byte_start":2656,"byte_end":2847,"line_start":99,"line_end":104,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            bpf_sk_redirect_hash(","highlight_start":13,"highlight_end":34},{"text":"                ctx.borrow().skb.skb,","highlight_start":1,"highlight_end":38},{"text":"                self.def.get().cast(),","highlight_start":1,"highlight_end":39},{"text":"                ptr::from_mut(key.borrow_mut()).cast(),","highlight_start":1,"highlight_end":56},{"text":"                flags,","highlight_start":1,"highlight_end":23},{"text":"            )","highlight_start":1,"highlight_end":14}],"label":"expected `i64`, found `i32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_hash.rs","byte_start":2621,"byte_end":2624,"line_start":97,"line_end":97,"column_start":10,"column_end":13,"is_primary":false,"text":[{"text":"    ) -> i64 {","highlight_start":10,"highlight_end":13}],"label":"expected `i64` because of return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can convert an `i32` to an `i64`","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_hash.rs","byte_start":2847,"byte_end":2847,"line_start":104,"line_end":104,"column_start":14,"column_end":14,"is_primary":true,"text":[{"text":"            )","highlight_start":14,"highlight_end":14}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n   \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_hash.rs:99:13\n    \u001b[1m\u001b[96m|\u001b[0m\n \u001b[1m\u001b[96m97\u001b[0m \u001b[1m\u001b[96m|\u001b[0m       ) -> i64 {\n    \u001b[1m\u001b[96m|\u001b[0m            \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[96mexpected `i64` because of return type\u001b[0m\n \u001b[1m\u001b[96m98\u001b[0m \u001b[1m\u001b[96m|\u001b[0m           unsafe {\n \u001b[1m\u001b[96m99\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m/\u001b[0m             bpf_sk_redirect_hash(\n\u001b[1m\u001b[96m100\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 ctx.borrow().skb.skb,\n\u001b[1m\u001b[96m101\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 self.def.get().cast(),\n\u001b[1m\u001b[96m102\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 ptr::from_mut(key.borrow_mut()).cast(),\n\u001b[1m\u001b[96m103\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m                 flags,\n\u001b[1m\u001b[96m104\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|\u001b[0m             )\n    \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[91m|_____________^\u001b[0m \u001b[1m\u001b[91mexpected `i64`, found `i32`\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert an `i32` to an `i64`\n    \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m104\u001b[0m \u001b[1m\u001b[96m| \u001b[0m            )\u001b[92m.into()\u001b[0m\n    \u001b[1m\u001b[96m|\u001b[0m              \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_map.rs","byte_start":1818,"byte_end":1821,"line_start":61,"line_end":61,"column_start":43,"column_end":46,"is_primary":true,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":43,"highlight_end":46}],"label":"expected `i64`, found `i32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_map.rs","byte_start":1814,"byte_end":1817,"line_start":61,"line_end":61,"column_start":39,"column_end":42,"is_primary":false,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":39,"highlight_end":42}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the type constructed contains `i32` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_map.rs","byte_start":1818,"byte_end":1821,"line_start":61,"line_end":61,"column_start":43,"column_end":46,"is_primary":false,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":43,"highlight_end":46}],"label":"this argument influences the type of `Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_map.rs","byte_start":1814,"byte_end":1822,"line_start":61,"line_end":61,"column_start":39,"column_end":47,"is_primary":true,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":39,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\result.rs","byte_start":21514,"byte_end":21517,"line_start":566,"line_end":566,"column_start":5,"column_end":8,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert an `i32` to an `i64`","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_map.rs","byte_start":1821,"byte_end":1821,"line_start":61,"line_end":61,"column_start":46,"column_end":46,"is_primary":true,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":46,"highlight_end":46}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_map.rs:61:43\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m61\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if ret == 0 { Ok(()) } else { Err(ret) }\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mexpected `i64`, found `i32`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[96marguments to this enum variant are incorrect\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `i32` due to the type of the argument passed\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_map.rs:61:39\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m61\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if ret == 0 { Ok(()) } else { Err(ret) }\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[96m^^^^\u001b[0m\u001b[1m\u001b[96m---\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                           \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                           \u001b[1m\u001b[96mthis argument influences the type of `Err`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n  \u001b[1m\u001b[96m--> \u001b[0m/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\result.rs:566:5\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert an `i32` to an `i64`\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m61\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        if ret == 0 { Ok(()) } else { Err(ret\u001b[92m.into()\u001b[0m) }\n   \u001b[1m\u001b[96m|\u001b[0m                                              \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_map.rs","byte_start":1982,"byte_end":2060,"line_start":66,"line_end":66,"column_start":18,"column_end":96,"is_primary":true,"text":[{"text":"        unsafe { bpf_msg_redirect_map(ctx.as_ptr().cast(), self.def.get().cast(), index, flags) }","highlight_start":18,"highlight_end":96}],"label":"expected `i64`, found `i32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_map.rs","byte_start":1959,"byte_end":1962,"line_start":65,"line_end":65,"column_start":86,"column_end":89,"is_primary":false,"text":[{"text":"    pub unsafe fn redirect_msg(&self, ctx: &SkMsgContext, index: u32, flags: u64) -> i64 {","highlight_start":86,"highlight_end":89}],"label":"expected `i64` because of return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can convert an `i32` to an `i64`","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_map.rs","byte_start":2060,"byte_end":2060,"line_start":66,"line_end":66,"column_start":96,"column_end":96,"is_primary":true,"text":[{"text":"        unsafe { bpf_msg_redirect_map(ctx.as_ptr().cast(), self.def.get().cast(), index, flags) }","highlight_start":96,"highlight_end":96}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_map.rs:66:18\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m65\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m fn redirect_msg(&self, ctx: &SkMsgContext, index: u32, flags: u64) -> i64 {\n   \u001b[1m\u001b[96m|\u001b[0m                                                                           \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[96mexpected `i64` because of return type\u001b[0m\n\u001b[1m\u001b[96m66\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m { bpf_msg_redirect_map(ctx.as_ptr().cast(), self.def.get().cast(), index, flags) }\n   \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `i64`, found `i32`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert an `i32` to an `i64`\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m66\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        unsafe { bpf_msg_redirect_map(ctx.as_ptr().cast(), self.def.get().cast(), index, flags)\u001b[92m.into()\u001b[0m }\n   \u001b[1m\u001b[96m|\u001b[0m                                                                                                \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_map.rs","byte_start":2221,"byte_end":2298,"line_start":71,"line_end":71,"column_start":18,"column_end":95,"is_primary":true,"text":[{"text":"        unsafe { bpf_sk_redirect_map(ctx.as_ptr().cast(), self.def.get().cast(), index, flags) }","highlight_start":18,"highlight_end":95}],"label":"expected `i64`, found `i32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_map.rs","byte_start":2198,"byte_end":2201,"line_start":70,"line_end":70,"column_start":87,"column_end":90,"is_primary":false,"text":[{"text":"    pub unsafe fn redirect_skb(&self, ctx: &SkBuffContext, index: u32, flags: u64) -> i64 {","highlight_start":87,"highlight_end":90}],"label":"expected `i64` because of return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"you can convert an `i32` to an `i64`","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_map.rs","byte_start":2298,"byte_end":2298,"line_start":71,"line_end":71,"column_start":95,"column_end":95,"is_primary":true,"text":[{"text":"        unsafe { bpf_sk_redirect_map(ctx.as_ptr().cast(), self.def.get().cast(), index, flags) }","highlight_start":95,"highlight_end":95}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\sock_map.rs:71:18\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m70\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m fn redirect_skb(&self, ctx: &SkBuffContext, index: u32, flags: u64) -> i64 {\n   \u001b[1m\u001b[96m|\u001b[0m                                                                            \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[96mexpected `i64` because of return type\u001b[0m\n\u001b[1m\u001b[96m71\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m { bpf_sk_redirect_map(ctx.as_ptr().cast(), self.def.get().cast(), index, flags) }\n   \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `i64`, found `i32`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert an `i32` to an `i64`\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m71\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        unsafe { bpf_sk_redirect_map(ctx.as_ptr().cast(), self.def.get().cast(), index, flags)\u001b[92m.into()\u001b[0m }\n   \u001b[1m\u001b[96m|\u001b[0m                                                                                               \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack.rs","byte_start":1567,"byte_end":1570,"line_start":54,"line_end":54,"column_start":40,"column_end":43,"is_primary":true,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":40,"highlight_end":43}],"label":"expected `i64`, found `i32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack.rs","byte_start":1561,"byte_end":1566,"line_start":54,"line_end":54,"column_start":34,"column_end":39,"is_primary":false,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":34,"highlight_end":39}],"label":"arguments to this method are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the return type of this call is `i32` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack.rs","byte_start":1567,"byte_end":1570,"line_start":54,"line_end":54,"column_start":40,"column_end":43,"is_primary":false,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":40,"highlight_end":43}],"label":"this argument influences the return type of `ok_or`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack.rs","byte_start":1536,"byte_end":1571,"line_start":54,"line_end":54,"column_start":9,"column_end":44,"is_primary":true,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":9,"highlight_end":44}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"method defined here","code":null,"level":"note","spans":[{"file_name":"/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\option.rs","byte_start":49826,"byte_end":49831,"line_start":1336,"line_end":1336,"column_start":18,"column_end":23,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert an `i32` to an `i64`","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack.rs","byte_start":1570,"byte_end":1570,"line_start":54,"line_end":54,"column_start":43,"column_end":43,"is_primary":true,"text":[{"text":"        (ret == 0).then_some(()).ok_or(ret)","highlight_start":43,"highlight_end":43}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack.rs:54:40\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m54\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         (ret == 0).then_some(()).ok_or(ret)\n   \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[96m-----\u001b[0m \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mexpected `i64`, found `i32`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                  \u001b[1m\u001b[96marguments to this method are incorrect\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the return type of this call is `i32` due to the type of the argument passed\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack.rs:54:9\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m54\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         (ret == 0).then_some(()).ok_or(ret)\n   \u001b[1m\u001b[96m|\u001b[0m         \u001b[1m\u001b[96m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[1m\u001b[96m---\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[96mthis argument influences the return type of `ok_or`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: method defined here\n  \u001b[1m\u001b[96m--> \u001b[0m/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\option.rs:1336:18\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert an `i32` to an `i64`\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m54\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        (ret == 0).then_some(()).ok_or(ret\u001b[92m.into()\u001b[0m)\n   \u001b[1m\u001b[96m|\u001b[0m                                           \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack_trace.rs","byte_start":1665,"byte_end":1668,"line_start":55,"line_end":55,"column_start":26,"column_end":29,"is_primary":true,"text":[{"text":"        if ret < 0 { Err(ret) } else { Ok(ret) }","highlight_start":26,"highlight_end":29}],"label":"expected `i64`, found `i32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack_trace.rs","byte_start":1661,"byte_end":1664,"line_start":55,"line_end":55,"column_start":22,"column_end":25,"is_primary":false,"text":[{"text":"        if ret < 0 { Err(ret) } else { Ok(ret) }","highlight_start":22,"highlight_end":25}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the type constructed contains `i32` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack_trace.rs","byte_start":1665,"byte_end":1668,"line_start":55,"line_end":55,"column_start":26,"column_end":29,"is_primary":false,"text":[{"text":"        if ret < 0 { Err(ret) } else { Ok(ret) }","highlight_start":26,"highlight_end":29}],"label":"this argument influences the type of `Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack_trace.rs","byte_start":1661,"byte_end":1669,"line_start":55,"line_end":55,"column_start":22,"column_end":30,"is_primary":true,"text":[{"text":"        if ret < 0 { Err(ret) } else { Ok(ret) }","highlight_start":22,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\result.rs","byte_start":21514,"byte_end":21517,"line_start":566,"line_end":566,"column_start":5,"column_end":8,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert an `i32` to an `i64`","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack_trace.rs","byte_start":1668,"byte_end":1668,"line_start":55,"line_end":55,"column_start":29,"column_end":29,"is_primary":true,"text":[{"text":"        if ret < 0 { Err(ret) } else { Ok(ret) }","highlight_start":29,"highlight_end":29}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack_trace.rs:55:26\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m55\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if ret < 0 { Err(ret) } else { Ok(ret) }\n   \u001b[1m\u001b[96m|\u001b[0m                      \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mexpected `i64`, found `i32`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                      \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                      \u001b[1m\u001b[96marguments to this enum variant are incorrect\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `i32` due to the type of the argument passed\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack_trace.rs:55:22\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m55\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if ret < 0 { Err(ret) } else { Ok(ret) }\n   \u001b[1m\u001b[96m|\u001b[0m                      \u001b[1m\u001b[96m^^^^\u001b[0m\u001b[1m\u001b[96m---\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                          \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                          \u001b[1m\u001b[96mthis argument influences the type of `Err`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n  \u001b[1m\u001b[96m--> \u001b[0m/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\result.rs:566:5\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert an `i32` to an `i64`\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m55\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        if ret < 0 { Err(ret\u001b[92m.into()\u001b[0m) } else { Ok(ret) }\n   \u001b[1m\u001b[96m|\u001b[0m                             \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack_trace.rs","byte_start":1682,"byte_end":1685,"line_start":55,"line_end":55,"column_start":43,"column_end":46,"is_primary":true,"text":[{"text":"        if ret < 0 { Err(ret) } else { Ok(ret) }","highlight_start":43,"highlight_end":46}],"label":"expected `i64`, found `i32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack_trace.rs","byte_start":1679,"byte_end":1681,"line_start":55,"line_end":55,"column_start":40,"column_end":42,"is_primary":false,"text":[{"text":"        if ret < 0 { Err(ret) } else { Ok(ret) }","highlight_start":40,"highlight_end":42}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the type constructed contains `i32` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack_trace.rs","byte_start":1682,"byte_end":1685,"line_start":55,"line_end":55,"column_start":43,"column_end":46,"is_primary":false,"text":[{"text":"        if ret < 0 { Err(ret) } else { Ok(ret) }","highlight_start":43,"highlight_end":46}],"label":"this argument influences the type of `Ok`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack_trace.rs","byte_start":1679,"byte_end":1686,"line_start":55,"line_end":55,"column_start":40,"column_end":47,"is_primary":true,"text":[{"text":"        if ret < 0 { Err(ret) } else { Ok(ret) }","highlight_start":40,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\result.rs","byte_start":21353,"byte_end":21355,"line_start":561,"line_end":561,"column_start":5,"column_end":7,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert an `i32` to an `i64`","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack_trace.rs","byte_start":1685,"byte_end":1685,"line_start":55,"line_end":55,"column_start":46,"column_end":46,"is_primary":true,"text":[{"text":"        if ret < 0 { Err(ret) } else { Ok(ret) }","highlight_start":46,"highlight_end":46}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack_trace.rs:55:43\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m55\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if ret < 0 { Err(ret) } else { Ok(ret) }\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[96m--\u001b[0m \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mexpected `i64`, found `i32`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[96marguments to this enum variant are incorrect\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `i32` due to the type of the argument passed\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\maps\\stack_trace.rs:55:40\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m55\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if ret < 0 { Err(ret) } else { Ok(ret) }\n   \u001b[1m\u001b[96m|\u001b[0m                                        \u001b[1m\u001b[96m^^^\u001b[0m\u001b[1m\u001b[96m---\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                           \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                           \u001b[1m\u001b[96mthis argument influences the type of `Ok`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n  \u001b[1m\u001b[96m--> \u001b[0m/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\result.rs:561:5\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert an `i32` to an `i64`\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m55\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        if ret < 0 { Err(ret) } else { Ok(ret\u001b[92m.into()\u001b[0m) }\n   \u001b[1m\u001b[96m|\u001b[0m                                              \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sk_msg.rs","byte_start":778,"byte_end":781,"line_start":32,"line_end":32,"column_start":43,"column_end":46,"is_primary":true,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":43,"highlight_end":46}],"label":"expected `i64`, found `i32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sk_msg.rs","byte_start":774,"byte_end":777,"line_start":32,"line_end":32,"column_start":39,"column_end":42,"is_primary":false,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":39,"highlight_end":42}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the type constructed contains `i32` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sk_msg.rs","byte_start":778,"byte_end":781,"line_start":32,"line_end":32,"column_start":43,"column_end":46,"is_primary":false,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":43,"highlight_end":46}],"label":"this argument influences the type of `Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sk_msg.rs","byte_start":774,"byte_end":782,"line_start":32,"line_end":32,"column_start":39,"column_end":47,"is_primary":true,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":39,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\result.rs","byte_start":21514,"byte_end":21517,"line_start":566,"line_end":566,"column_start":5,"column_end":8,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert an `i32` to an `i64`","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sk_msg.rs","byte_start":781,"byte_end":781,"line_start":32,"line_end":32,"column_start":46,"column_end":46,"is_primary":true,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":46,"highlight_end":46}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sk_msg.rs:32:43\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m32\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if ret == 0 { Ok(()) } else { Err(ret) }\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mexpected `i64`, found `i32`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[96marguments to this enum variant are incorrect\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `i32` due to the type of the argument passed\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sk_msg.rs:32:39\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m32\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if ret == 0 { Ok(()) } else { Err(ret) }\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[96m^^^^\u001b[0m\u001b[1m\u001b[96m---\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                           \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                           \u001b[1m\u001b[96mthis argument influences the type of `Err`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n  \u001b[1m\u001b[96m--> \u001b[0m/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\result.rs:566:5\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert an `i32` to an `i64`\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m32\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        if ret == 0 { Ok(()) } else { Err(ret\u001b[92m.into()\u001b[0m) }\n   \u001b[1m\u001b[96m|\u001b[0m                                              \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sk_msg.rs","byte_start":992,"byte_end":995,"line_start":37,"line_end":37,"column_start":43,"column_end":46,"is_primary":true,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":43,"highlight_end":46}],"label":"expected `i64`, found `i32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sk_msg.rs","byte_start":988,"byte_end":991,"line_start":37,"line_end":37,"column_start":39,"column_end":42,"is_primary":false,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":39,"highlight_end":42}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the type constructed contains `i32` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sk_msg.rs","byte_start":992,"byte_end":995,"line_start":37,"line_end":37,"column_start":43,"column_end":46,"is_primary":false,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":43,"highlight_end":46}],"label":"this argument influences the type of `Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sk_msg.rs","byte_start":988,"byte_end":996,"line_start":37,"line_end":37,"column_start":39,"column_end":47,"is_primary":true,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":39,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\result.rs","byte_start":21514,"byte_end":21517,"line_start":566,"line_end":566,"column_start":5,"column_end":8,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert an `i32` to an `i64`","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sk_msg.rs","byte_start":995,"byte_end":995,"line_start":37,"line_end":37,"column_start":46,"column_end":46,"is_primary":true,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":46,"highlight_end":46}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sk_msg.rs:37:43\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m37\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if ret == 0 { Ok(()) } else { Err(ret) }\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mexpected `i64`, found `i32`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[96marguments to this enum variant are incorrect\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `i32` due to the type of the argument passed\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sk_msg.rs:37:39\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m37\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if ret == 0 { Ok(()) } else { Err(ret) }\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[96m^^^^\u001b[0m\u001b[1m\u001b[96m---\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                           \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                           \u001b[1m\u001b[96mthis argument influences the type of `Err`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n  \u001b[1m\u001b[96m--> \u001b[0m/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\result.rs:566:5\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert an `i32` to an `i64`\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m37\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        if ret == 0 { Ok(()) } else { Err(ret\u001b[92m.into()\u001b[0m) }\n   \u001b[1m\u001b[96m|\u001b[0m                                              \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sock_ops.rs","byte_start":722,"byte_end":725,"line_start":30,"line_end":30,"column_start":43,"column_end":46,"is_primary":true,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":43,"highlight_end":46}],"label":"expected `i64`, found `i32`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sock_ops.rs","byte_start":718,"byte_end":721,"line_start":30,"line_end":30,"column_start":39,"column_end":42,"is_primary":false,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":39,"highlight_end":42}],"label":"arguments to this enum variant are incorrect","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"the type constructed contains `i32` due to the type of the argument passed","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sock_ops.rs","byte_start":722,"byte_end":725,"line_start":30,"line_end":30,"column_start":43,"column_end":46,"is_primary":false,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":43,"highlight_end":46}],"label":"this argument influences the type of `Err`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sock_ops.rs","byte_start":718,"byte_end":726,"line_start":30,"line_end":30,"column_start":39,"column_end":47,"is_primary":true,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":39,"highlight_end":47}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"tuple variant defined here","code":null,"level":"note","spans":[{"file_name":"/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\result.rs","byte_start":21514,"byte_end":21517,"line_start":566,"line_end":566,"column_start":5,"column_end":8,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"you can convert an `i32` to an `i64`","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sock_ops.rs","byte_start":725,"byte_end":725,"line_start":30,"line_end":30,"column_start":46,"column_end":46,"is_primary":true,"text":[{"text":"        if ret == 0 { Ok(()) } else { Err(ret) }","highlight_start":46,"highlight_end":46}],"label":null,"suggested_replacement":".into()","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sock_ops.rs:30:43\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m30\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if ret == 0 { Ok(()) } else { Err(ret) }\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[96m---\u001b[0m \u001b[1m\u001b[91m^^^\u001b[0m \u001b[1m\u001b[91mexpected `i64`, found `i32`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[96marguments to this enum variant are incorrect\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96mhelp\u001b[0m: the type constructed contains `i32` due to the type of the argument passed\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\sock_ops.rs:30:39\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m30\u001b[0m \u001b[1m\u001b[96m|\u001b[0m         if ret == 0 { Ok(()) } else { Err(ret) }\n   \u001b[1m\u001b[96m|\u001b[0m                                       \u001b[1m\u001b[96m^^^^\u001b[0m\u001b[1m\u001b[96m---\u001b[0m\u001b[1m\u001b[96m^\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                           \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m                                           \u001b[1m\u001b[96mthis argument influences the type of `Err`\u001b[0m\n\u001b[1m\u001b[92mnote\u001b[0m: tuple variant defined here\n  \u001b[1m\u001b[96m--> \u001b[0m/rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234\\library\\core\\src\\result.rs:566:5\n\u001b[1m\u001b[96mhelp\u001b[0m: you can convert an `i32` to an `i64`\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m30\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        if ret == 0 { Ok(()) } else { Err(ret\u001b[92m.into()\u001b[0m) }\n   \u001b[1m\u001b[96m|\u001b[0m                                              \u001b[92m+++++++\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"mismatched types","code":{"code":"E0308","explanation":"Expected type did not match the received type.\n\nErroneous code examples:\n\n```compile_fail,E0308\nfn plus_one(x: i32) -> i32 {\n    x + 1\n}\n\nplus_one(\"Not a number\");\n//       ^^^^^^^^^^^^^^ expected `i32`, found `&str`\n\nif \"Not a bool\" {\n// ^^^^^^^^^^^^ expected `bool`, found `&str`\n}\n\nlet x: f32 = \"Not a float\";\n//     ---   ^^^^^^^^^^^^^ expected `f32`, found `&str`\n//     |\n//     expected due to this\n```\n\nThis error occurs when an expression was used in a place where the compiler\nexpected an expression of a different type. It can occur in several cases, the\nmost common being when calling a function and passing an argument which has a\ndifferent type than the matching type in the function declaration.\n"},"level":"error","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\tracepoint.rs","byte_start":358,"byte_end":401,"line_start":16,"line_end":16,"column_start":18,"column_end":61,"is_primary":true,"text":[{"text":"        unsafe { bpf_probe_read(self.ctx.add(offset).cast()) }","highlight_start":18,"highlight_end":61}],"label":"expected `Result<T, i64>`, found `Result<_, i32>`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\tracepoint.rs","byte_start":324,"byte_end":338,"line_start":15,"line_end":15,"column_start":55,"column_end":69,"is_primary":false,"text":[{"text":"    pub unsafe fn read_at<T>(&self, offset: usize) -> Result<T, i64> {","highlight_start":55,"highlight_end":69}],"label":"expected `Result<T, i64>` because of return type","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"expected enum `Result<T, i64>`\n   found enum `Result<_, i32>`","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"use the `?` operator to extract the `Result<_, i32>` value, propagating a `Result::Err` value to the caller","code":null,"level":"help","spans":[{"file_name":"C:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\tracepoint.rs","byte_start":401,"byte_end":401,"line_start":16,"line_end":16,"column_start":61,"column_end":61,"is_primary":true,"text":[{"text":"        unsafe { bpf_probe_read(self.ctx.add(offset).cast()) }","highlight_start":61,"highlight_end":61}],"label":null,"suggested_replacement":"?","suggestion_applicability":"HasPlaceholders","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[1m\u001b[91merror[E0308]\u001b[0m\u001b[1m\u001b[97m: mismatched types\u001b[0m\n  \u001b[1m\u001b[96m--> \u001b[0mC:\\Users\\Kent Burchard\\.cargo\\git\\checkouts\\aya-c5ab473414e1dedb\\3b28447\\ebpf\\aya-ebpf\\src\\programs\\tracepoint.rs:16:18\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m15\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m fn read_at<T>(&self, offset: usize) -> Result<T, i64> {\n   \u001b[1m\u001b[96m|\u001b[0m                                            \u001b[1m\u001b[96m--------------\u001b[0m \u001b[1m\u001b[96mexpected `Result<T, i64>` because of return type\u001b[0m\n\u001b[1m\u001b[96m16\u001b[0m \u001b[1m\u001b[96m|\u001b[0m \u001b[1m\u001b[96m...\u001b[0m { bpf_probe_read(self.ctx.add(offset).cast()) }\n   \u001b[1m\u001b[96m|\u001b[0m       \u001b[1m\u001b[91m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m \u001b[1m\u001b[91mexpected `Result<T, i64>`, found `Result<_, i32>`\u001b[0m\n   \u001b[1m\u001b[96m|\u001b[0m\n   \u001b[1m\u001b[96m= \u001b[0m\u001b[1m\u001b[97mnote\u001b[0m: expected enum `Result<\u001b[1m\u001b[35mT\u001b[0m, \u001b[1m\u001b[35mi64\u001b[0m>`\n              found enum `Result<\u001b[1m\u001b[35m_\u001b[0m, \u001b[1m\u001b[35mi32\u001b[0m>`\n\u001b[1m\u001b[96mhelp\u001b[0m: use the `?` operator to extract the `Result<_, i32>` value, propagating a `Result::Err` value to the caller\n   \u001b[1m\u001b[96m|\u001b[0m\n\u001b[1m\u001b[96m16\u001b[0m \u001b[1m\u001b[96m| \u001b[0m        unsafe { bpf_probe_read(self.ctx.add(offset).cast())\u001b[92m?\u001b[0m }\n   \u001b[1m\u001b[96m|\u001b[0m                                                             \u001b[92m+\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"aborting due to 20 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[1m\u001b[91merror\u001b[0m\u001b[1m\u001b[97m: aborting due to 20 previous errors\u001b[0m\n\n"}
{"$message_type":"diagnostic","message":"For more information about this error, try `rustc --explain E0308`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[1m\u001b[97mFor more information about this error, try `rustc --explain E0308`.\u001b[0m\n"}
